package chess.mlp;

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;

/**
 * Simple binary loader for MLP weights exported from Python.
 *
 * Expected file layout (all little-endian int32/float32, written with DataOutputStream in Python):
 * For each matrix in order: w1, b1, w2, b2, w3, b3, wScalar, bScalar, wGrid, bGrid:
 *   - int rows, int cols (for vectors, use rows=N, cols=1)
 *   - rows * cols float32 values in row-major order
 * Recommended location: {@code models/mlp_dual_wide.bin} (exported via {@code src/chess/nn2/export_weights.py}).
 * 
 * Use {@link #load(Path)} for the binary or {@link #loadFromTextDir(Path)} if you prefer the
 * per-layer text export (w1.txt, b1.txt, ...).
 * 
 * @author Lennart A. Conrad
 */
public final class WeightsLoader {

    /**
     * Utility class; not instantiable.
     */
    private WeightsLoader() {}

    /**
     * Load weights from a binary file on disk.
     *
     * @param path path to the binary weight file
     * @return initialized {@link Evaluator}
     * @throws IOException if the file cannot be read or parsed
     */
    public static Evaluator load(Path path) throws IOException {
        try (DataInputStream in = new DataInputStream(new BufferedInputStream(Files.newInputStream(path)))) {
            return readAll(in);
        }
    }

    /**
     * Load weights from an in-memory byte array containing the binary format.
     *
     * @param data binary contents of the weight file
     * @return initialized {@link Evaluator}
     * @throws IOException if the data cannot be parsed
     */
    public static Evaluator load(byte[] data) throws IOException {
        try (DataInputStream in = new DataInputStream(new BufferedInputStream(new ByteArrayInputStream(data)))) {
            return readAll(in);
        }
    }

    /**
     * Parse the full set of matrices/vectors from a {@link DataInputStream}.
     *
     * @param in input stream containing the binary weight format
     * @return evaluator initialized with all weights
     * @throws IOException if the stream cannot be read or is malformed
     */
    private static Evaluator readAll(DataInputStream in) throws IOException {
        Evaluator.LayerParams l1 = new Evaluator.LayerParams(readMatrix(in), readVector(in));
        Evaluator.LayerParams l2 = new Evaluator.LayerParams(readMatrix(in), readVector(in));
        Evaluator.LayerParams l3 = new Evaluator.LayerParams(readMatrix(in), readVector(in));
        Evaluator.LayerParams scalar = new Evaluator.LayerParams(readMatrix(in), readVector(in));
        Evaluator.LayerParams grid = new Evaluator.LayerParams(readMatrix(in), readVector(in));
        return new Evaluator(l1, l2, l3, scalar, grid);
    }

    /**
     * Read a 2D matrix (rows, cols, then row-major float32 data).
     *
     * @param in input stream
     * @return parsed matrix
     * @throws IOException if reading fails
     */
    private static float[][] readMatrix(DataInputStream in) throws IOException {
        int rows = readIntLE(in);
        int cols = readIntLE(in);
        float[][] out = new float[rows][cols];
        for (int r = 0; r < rows; r++) {
            for (int c = 0; c < cols; c++) {
                out[r][c] = readFloatLE(in);
            }
        }
        return out;
    }

    /**
     * Read a vector (rows, cols, then float32 data); flattens any extra columns.
     *
     * @param in input stream
     * @return parsed vector
     * @throws IOException if reading fails
     */
    private static float[] readVector(DataInputStream in) throws IOException {
        int rows = readIntLE(in);
        int cols = readIntLE(in); // should be 1
        float[] out = new float[rows];
        for (int i = 0; i < rows; i++) {
            out[i] = readFloatLE(in);
        }
        // discard any extra columns (not expected)
        for (int i = 1; i < cols; i++) {
            for (int j = 0; j < rows; j++) {
                readFloatLE(in);
            }
        }
        return out;
    }

    /**
     * Helper to load from per-layer text files (e.g., generated by export_weights.py).
     * Expects files named w1.txt, b1.txt, w2.txt, b2.txt, w3.txt, b3.txt, wS.txt, bS.txt, wG.txt, bG.txt.
     *
     * @param dir directory containing the layer text files
     * @return evaluator initialized with all weights
     * @throws IOException if any file cannot be read or parsed
     */
    public static Evaluator loadFromTextDir(Path dir) throws IOException {
        Evaluator.LayerParams l1 = new Evaluator.LayerParams(readMatrixTxt(dir.resolve("w1.txt")), readVectorTxt(dir.resolve("b1.txt")));
        Evaluator.LayerParams l2 = new Evaluator.LayerParams(readMatrixTxt(dir.resolve("w2.txt")), readVectorTxt(dir.resolve("b2.txt")));
        Evaluator.LayerParams l3 = new Evaluator.LayerParams(readMatrixTxt(dir.resolve("w3.txt")), readVectorTxt(dir.resolve("b3.txt")));
        Evaluator.LayerParams scalar = new Evaluator.LayerParams(readMatrixTxt(dir.resolve("wS.txt")), readVectorTxt(dir.resolve("bS.txt")));
        Evaluator.LayerParams grid = new Evaluator.LayerParams(readMatrixTxt(dir.resolve("wG.txt")), readVectorTxt(dir.resolve("bG.txt")));
        return new Evaluator(l1, l2, l3, scalar, grid);
    }

    /**
     * Read a whitespace-separated matrix from a text file.
     *
     * @param path path to the text file
     * @return parsed matrix
     * @throws IOException if reading fails
     */
    private static float[][] readMatrixTxt(Path path) throws IOException {
        try (var lines = Files.lines(path)) {
            var list = lines.toList();
            int rows = list.size();
            float[][] out = new float[rows][];
            for (int r = 0; r < rows; r++) {
                String line = list.get(r).trim();
                if (line.isEmpty()) {
                    out[r] = new float[0];
                    continue;
                }
                String[] parts = line.split("\\s+");
                out[r] = new float[parts.length];
                for (int c = 0; c < parts.length; c++) {
                    out[r][c] = Float.parseFloat(parts[c]);
                }
            }
            return out;
        }
    }

    /**
     * Read a vector from text; accepts single-row or column-style inputs.
     *
     * @param path path to the text file
     * @return parsed vector
     * @throws IOException if reading fails
     */
    private static float[] readVectorTxt(Path path) throws IOException {
        float[][] m = readMatrixTxt(path);
        if (m.length == 1) {
            return m[0];
        }
        // If read as column (N x 1), flatten
        int len = Arrays.stream(m).mapToInt(row -> row.length).sum();
        float[] out = new float[len];
        int idx = 0;
        for (float[] row : m) {
            for (float v : row) out[idx++] = v;
        }
        return out;
    }

    private static int readIntLE(DataInputStream in) throws IOException {
        int b1 = in.readUnsignedByte();
        int b2 = in.readUnsignedByte();
        int b3 = in.readUnsignedByte();
        int b4 = in.readUnsignedByte();
        return (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;
    }

    private static float readFloatLE(DataInputStream in) throws IOException {
        return Float.intBitsToFloat(readIntLE(in));
    }
}
